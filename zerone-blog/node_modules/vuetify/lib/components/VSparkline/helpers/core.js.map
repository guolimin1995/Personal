{"version":3,"sources":["../../../../src/components/VSparkline/helpers/core.ts"],"names":[],"mappings":";;OAEM,SAAU,SAAV,CACJ,MADI,EAEJ,QAFI,EAEc;AAAA,QAEV,IAFU,GAEiB,QAFjB,CAEV,IAFU;AAAA,QAEJ,IAFI,GAEiB,QAFjB,CAEJ,IAFI;AAAA,QAEE,IAFF,GAEiB,QAFjB,CAEE,IAFF;AAAA,QAEQ,IAFR,GAEiB,QAFjB,CAEQ,IAFR;;AAGlB,QAAM,cAAc,OAAO,MAA3B;AACA,QAAM,WAAW,KAAK,GAAL,gCAAY,MAAZ,EAAjB;AACA,QAAM,WAAW,KAAK,GAAL,gCAAY,MAAZ,EAAjB;AAEA,QAAM,QAAQ,CAAC,OAAO,IAAR,KAAiB,cAAc,CAA/B,CAAd;AACA,QAAM,QAAQ,CAAC,OAAO,IAAR,KAAiB,WAAW,QAA5B,CAAd;AAEA,WAAO,OAAO,GAAP,CAAW,UAAC,KAAD,EAAQ,KAAR,EAAiB;AACjC,eAAO;AACL,eAAG,OAAO,QAAQ,KADb;AAEL,eACE,OACA,CAAC,QAAQ,QAAT,IAAqB,KADrB,GAEA,EAAE,UAAU,cAAc,CAA1B,IAA+B,OAF/B,GAGA,EAAE,UAAU,CAAZ,IAAiB,OANd;AAOL;AAPK,SAAP;AASD,KAVM,CAAP;AAWD;AAED,OAAM,SAAU,OAAV,CACJ,MADI,EAEJ,QAFI,EAEc;AAAA,QAEV,IAFU,GAEiB,QAFjB,CAEV,IAFU;AAAA,QAEJ,IAFI,GAEiB,QAFjB,CAEJ,IAFI;AAAA,QAEE,IAFF,GAEiB,QAFjB,CAEE,IAFF;AAAA,QAEQ,IAFR,GAEiB,QAFjB,CAEQ,IAFR;;AAGlB,QAAM,cAAc,OAAO,MAA3B;AACA,QAAM,WAAW,KAAK,GAAL,gCAAY,MAAZ,EAAjB;AACA,QAAM,WAAW,KAAK,GAAL,gCAAY,MAAZ,EAAjB;AAEA,QAAM,QAAQ,OAAO,WAArB;AACA,QAAM,QAAQ,CAAC,OAAO,IAAR,KAAiB,WAAW,QAA5B,CAAd;AACA,QAAM,WAAW,OAAO,KAAK,GAAL,CAAS,WAAW,KAApB,CAAxB;AAEA,WAAO,OAAO,GAAP,CAAW,UAAC,KAAD,EAAQ,KAAR,EAAiB;AACjC,YAAM,SAAS,KAAK,GAAL,CAAS,QAAQ,KAAjB,CAAf;AAEA,eAAO;AACL,eAAG,OAAO,QAAQ,KADb;AAEL,eAAG,WAAW,MAAX,GACD,EAAE,QAAQ,CAAV,IAAe,MAHZ;AAIL,0BAJK;AAKL;AALK,SAAP;AAOD,KAVM,CAAP;AAWD","sourcesContent":["import { Point, Boundary, Bar } from '../VSparkline'\n\nexport function genPoints (\n  values: number[],\n  boundary: Boundary\n): Point[] {\n  const { minX, maxX, minY, maxY } = boundary\n  const totalValues = values.length\n  const maxValue = Math.max(...values)\n  const minValue = Math.min(...values)\n\n  const gridX = (maxX - minX) / (totalValues - 1)\n  const gridY = (maxY - minY) / (maxValue - minValue)\n\n  return values.map((value, index) => {\n    return {\n      x: minX + index * gridX,\n      y:\n        maxY -\n        (value - minValue) * gridY +\n        +(index === totalValues - 1) * 0.00001 -\n        +(index === 0) * 0.00001,\n      value,\n    }\n  })\n}\n\nexport function genBars (\n  values: number[],\n  boundary: Boundary\n): Bar[] {\n  const { minX, maxX, minY, maxY } = boundary\n  const totalValues = values.length\n  const maxValue = Math.max(...values)\n  const minValue = Math.min(...values)\n\n  const gridX = maxX / totalValues\n  const gridY = (maxY - minY) / (maxValue - minValue)\n  const horizonY = maxY - Math.abs(minValue * gridY)\n\n  return values.map((value, index) => {\n    const height = Math.abs(gridY * value)\n\n    return {\n      x: minX + index * gridX,\n      y: horizonY - height +\n        +(value < 0) * height,\n      height,\n      value,\n    }\n  })\n}\n"],"sourceRoot":""}